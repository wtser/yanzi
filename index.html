<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>燕子飞计时记录</title>
  <style>
    :root {
      --bg: #070a1a;
      --panel: rgba(255, 255, 255, 0.08);
      --panel2: rgba(255, 255, 255, 0.11);
      --text: rgba(255, 255, 255, 0.94);
      --muted: rgba(255, 255, 255, 0.78);
      --muted2: rgba(255, 255, 255, 0.62);
      --border: rgba(255, 255, 255, 0.14);
      --accent: #8b5cf6;
      --green: #34d399;
      --amber: #fbbf24;
      --red: #fb7185;
      --shadow: 0 28px 80px rgba(0,0,0,0.46);
      --radius: 20px;
      --radius2: 26px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(139, 92, 246, 0.38), transparent 60%),
        radial-gradient(1000px 800px at 90% 30%, rgba(52, 211, 153, 0.22), transparent 55%),
        radial-gradient(900px 700px at 55% 90%, rgba(251, 191, 36, 0.24), transparent 55%),
        radial-gradient(850px 650px at 10% 90%, rgba(251, 113, 133, 0.18), transparent 60%),
        var(--bg);
      color: var(--text);
    }

    .wrap {
      max-width: 920px;
      margin: 0 auto;
      padding: 22px 14px 44px;
    }

    header {
      display: flex;
      gap: 12px;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    h1 {
      font-size: 22px;
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      padding: 8px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }

    .grid {
      display: grid;
      grid-template-columns: 3fr 1fr;
      gap: 14px;
    }

    @media (max-width: 820px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background:
        radial-gradient(120% 120% at 10% 0%, rgba(255,255,255,0.10), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      border: 1px solid var(--border);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .inner {
      padding: 16px;
    }

    .main {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 14px;
      align-items: stretch;
    }

    @media (max-width: 820px) {
      .main { grid-template-columns: 1fr; }
    }

    .status {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .stage {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      color: var(--muted);
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.18);
    }

    .dot.work { background: var(--green); box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.18); }
    .dot.rest { background: var(--amber); box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.20); }
    .dot.done { background: rgba(255,255,255,0.35); box-shadow: 0 0 0 4px rgba(255,255,255,0.10); }

    .timer {
      font-variant-numeric: tabular-nums;
      font-size: clamp(56px, 9vw, 84px);
      font-weight: 800;
      letter-spacing: 0.6px;
      margin: 0;
      line-height: 1.04;
      text-shadow: 0 10px 30px rgba(0,0,0,0.34);
    }

    .metaRow {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .kv {
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
    }

    .k { font-size: 12px; color: var(--muted2); margin-bottom: 6px; }
    .v { font-size: 18px; font-weight: 700; }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
      margin-top: 6px;
    }

    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 16px;
      padding: 12px 16px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }

    button:hover { background: rgba(255,255,255,0.10); }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: 0.55; cursor: not-allowed; }

    .primary {
      border-color: rgba(124, 58, 237, 0.40);
      background: rgba(124, 58, 237, 0.22);
    }

    .danger {
      border-color: rgba(239, 68, 68, 0.45);
      background: rgba(239, 68, 68, 0.18);
    }

    .secondary {
      border-color: rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.05);
    }

    .side {
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }

    .config {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    @media (max-width: 520px) {
      .config { grid-template-columns: 1fr; }
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }

    input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }

    select {
      width: 100%;
      height: 42px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }

    input:focus { border-color: rgba(124, 58, 237, 0.55); }

    .hint {
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.5;
      margin-top: 10px;
    }

    .progress {
      height: 10px;
      background: rgba(255,255,255,0.06);
      border-top: 1px solid rgba(255,255,255,0.10);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }

    .bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, rgba(34, 197, 94, 0.9), rgba(124, 58, 237, 0.9));
      transition: width 120ms linear;
    }

    .toast {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.22);
      color: var(--muted);
      font-size: 12px;
      min-height: 40px;
      display: flex;
      align-items: center;
    }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>燕子飞计时记录</h1>
        <div class="subtitle">每组 120s 训练 + 10s 休息，共 22 组。支持中途暂停/继续，自动保存进度（刷新不丢）。</div>
      </div>
      <div class="pill">
        <span class="kbd">Space</span>
        <span>开始/暂停</span>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="inner main">
          <div class="status">
            <div class="stage">
              <div class="badge" id="stageBadge">
                <span class="dot work" id="stageDot"></span>
                <span id="stageText">准备</span>
              </div>
              <div class="badge">
                <span>目标</span>
                <strong id="targetSets">22</strong>
                <span>组</span>
              </div>
            </div>

            <p class="timer" id="timerText">02:00</p>

            <div class="metaRow">
              <div class="kv">
                <div class="k">当前组</div>
                <div class="v"><span id="currentSet">1</span>/<span id="totalSets">22</span></div>
              </div>
              <div class="kv">
                <div class="k">已完成</div>
                <div class="v"><span id="completedSets">0</span> 组</div>
              </div>
            </div>

            <div class="controls">
              <button class="primary" id="btnStart">开始</button>
              <button class="secondary" id="btnPause" disabled>暂停</button>
              <button class="secondary" id="btnResume" disabled>继续</button>
              <button class="danger" id="btnReset">重置</button>
            </div>

            <div class="toast" id="toast">就绪。点击“开始”或按空格键。</div>
          </div>

          <div>
            <div class="kv" style="margin-bottom: 10px;">
              <div class="k">本阶段进度</div>
              <div class="v" id="phaseProgressText">0%</div>
            </div>
            <div class="progress" aria-hidden="true"><div class="bar" id="phaseBar"></div></div>

            <div class="inner" style="padding: 0; margin-top: 14px;">
              <div class="config">
                <label>
                  训练时长（秒）
                  <input id="workSeconds" inputmode="numeric" pattern="[0-9]*" value="120" />
                </label>
                <label>
                  休息时长（秒）
                  <input id="restSeconds" inputmode="numeric" pattern="[0-9]*" value="10" />
                </label>
                <label>
                  组数
                  <input id="setCount" inputmode="numeric" pattern="[0-9]*" value="22" />
                </label>
                <label>
                  声音提示
                  <input id="soundToggle" type="checkbox" checked style="height: 42px;" />
                </label>
                <label>
                  语音音色
                  <select id="voiceSelect">
                    <option value="">系统默认</option>
                  </select>
                </label>
                <label>
                  防止息屏
                  <input id="wakeLockToggle" type="checkbox" checked style="height: 42px;" />
                </label>
              </div>

              <div class="hint">
                说明：修改配置后会在下一次“开始/重置”时生效。正在计时中不会强制打断。
              </div>
            </div>
          </div>
        </div>
        <div class="side">
          <div class="inner hint">
            快捷键：<span class="kbd">Space</span> 开始/暂停。页面会自动保存进度；想清零请点击“重置”。
          </div>
        </div>
      </div>

      <div class="card">
        <div class="inner">
          <div class="kv" style="margin-bottom: 10px;">
            <div class="k">今日记录</div>
            <div class="v" id="todaySummary">—</div>
          </div>
          <div class="kv" style="margin-bottom: 10px;">
            <div class="k">状态</div>
            <div class="v" id="runState">未开始</div>
          </div>
          <div class="kv" style="margin-bottom: 10px;">
            <div class="k">防止息屏</div>
            <div class="v" id="wakeLockState">—</div>
          </div>
          <div class="kv">
            <div class="k">数据保存</div>
            <div class="v" id="persistState">本地自动保存</div>
          </div>
          <div class="hint" style="margin-top: 12px;">
            如果你希望“每天自动清零”，我也可以加一个“按日期归档”的记录表。
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'yanzi_fly_v1';

    const els = {
      stageDot: document.getElementById('stageDot'),
      stageText: document.getElementById('stageText'),
      timerText: document.getElementById('timerText'),
      currentSet: document.getElementById('currentSet'),
      totalSets: document.getElementById('totalSets'),
      targetSets: document.getElementById('targetSets'),
      completedSets: document.getElementById('completedSets'),
      btnStart: document.getElementById('btnStart'),
      btnPause: document.getElementById('btnPause'),
      btnResume: document.getElementById('btnResume'),
      btnReset: document.getElementById('btnReset'),
      toast: document.getElementById('toast'),
      phaseBar: document.getElementById('phaseBar'),
      phaseProgressText: document.getElementById('phaseProgressText'),
      workSeconds: document.getElementById('workSeconds'),
      restSeconds: document.getElementById('restSeconds'),
      setCount: document.getElementById('setCount'),
      soundToggle: document.getElementById('soundToggle'),
      voiceSelect: document.getElementById('voiceSelect'),
      wakeLockToggle: document.getElementById('wakeLockToggle'),
      todaySummary: document.getElementById('todaySummary'),
      runState: document.getElementById('runState'),
      wakeLockState: document.getElementById('wakeLockState'),
      persistState: document.getElementById('persistState'),
    };

    const defaultConfig = { workSeconds: 120, restSeconds: 10, totalSets: 22, sound: true, voiceURI: '', wakeLock: true };

    let tickTimer = null;

    let state = {
      config: { ...defaultConfig },
      phase: 'idle',
      running: false,
      paused: false,
      currentSet: 1,
      completedSets: 0,
      phaseDurationMs: 120000,
      phaseRemainingMs: 120000,
      lastTs: null,
      startedAtLocalISO: null,
      lastSavedAt: null,
    };

    function nowMs() {
      return performance && performance.now ? performance.now() : Date.now();
    }

    function clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
    }

    function pad2(n) {
      const s = String(Math.floor(n));
      return s.length >= 2 ? s : '0' + s;
    }

    function formatMs(ms) {
      const totalSec = Math.max(0, Math.ceil(ms / 1000));
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${pad2(m)}:${pad2(s)}`;
    }

    function stageLabel(phase) {
      if (phase === 'work') return '训练中';
      if (phase === 'rest') return '休息中';
      if (phase === 'done') return '已完成';
      return '准备';
    }

    function setDot(phase) {
      els.stageDot.classList.remove('work', 'rest', 'done');
      if (phase === 'work') els.stageDot.classList.add('work');
      else if (phase === 'rest') els.stageDot.classList.add('rest');
      else if (phase === 'done') els.stageDot.classList.add('done');
      else els.stageDot.classList.add('done');
    }

    function toast(msg) {
      els.toast.textContent = msg;
    }

    function readConfigFromInputs() {
      const w = parseInt(String(els.workSeconds.value || ''), 10);
      const r = parseInt(String(els.restSeconds.value || ''), 10);
      const t = parseInt(String(els.setCount.value || ''), 10);
      const sound = !!els.soundToggle.checked;
      const voiceURI = String(els.voiceSelect && els.voiceSelect.value ? els.voiceSelect.value : '');
      const wakeLock = !!(els.wakeLockToggle && els.wakeLockToggle.checked);

      const workSeconds = Number.isFinite(w) ? clamp(w, 1, 3600) : defaultConfig.workSeconds;
      const restSeconds = Number.isFinite(r) ? clamp(r, 0, 3600) : defaultConfig.restSeconds;
      const totalSets = Number.isFinite(t) ? clamp(t, 1, 999) : defaultConfig.totalSets;

      return { workSeconds, restSeconds, totalSets, sound, voiceURI, wakeLock };
    }

    function applyConfigToInputs(cfg) {
      els.workSeconds.value = String(cfg.workSeconds);
      els.restSeconds.value = String(cfg.restSeconds);
      els.setCount.value = String(cfg.totalSets);
      els.soundToggle.checked = !!cfg.sound;

      if (els.voiceSelect) {
        els.voiceSelect.value = cfg.voiceURI ? String(cfg.voiceURI) : '';
      }

      if (els.wakeLockToggle) {
        els.wakeLockToggle.checked = cfg.wakeLock !== undefined ? !!cfg.wakeLock : true;
      }

      els.totalSets.textContent = String(cfg.totalSets);
      els.targetSets.textContent = String(cfg.totalSets);
    }

    function saveState() {
      const payload = {
        ...state,
        lastSavedAt: new Date().toISOString(),
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (e) {
        els.persistState.textContent = '无法保存（浏览器限制）';
      }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return false;

        const cfg = parsed.config && typeof parsed.config === 'object' ? parsed.config : defaultConfig;
        const loadedConfig = {
          workSeconds: Number(cfg.workSeconds) || defaultConfig.workSeconds,
          restSeconds: Number(cfg.restSeconds) || defaultConfig.restSeconds,
          totalSets: Number(cfg.totalSets) || defaultConfig.totalSets,
          sound: cfg.sound !== undefined ? !!cfg.sound : defaultConfig.sound,
          voiceURI: cfg.voiceURI !== undefined ? String(cfg.voiceURI) : defaultConfig.voiceURI,
          wakeLock: cfg.wakeLock !== undefined ? !!cfg.wakeLock : defaultConfig.wakeLock,
        };

        state = {
          ...state,
          ...parsed,
          config: loadedConfig,
          running: false,
          paused: parsed.paused ? true : false,
          lastTs: null,
        };

        return true;
      } catch (e) {
        return false;
      }
    }

    function clearSavedState() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (e) {}
    }

    function speak(text) {
      if (!state.config.sound) return;
      const synth = window.speechSynthesis;
      const Utter = window.SpeechSynthesisUtterance;
      if (!synth || !Utter) return;

      try {
        synth.cancel();
        const u = new Utter(text);
        u.lang = 'zh-CN';
        u.rate = 1;
        u.pitch = 1;
        u.volume = 1;

        if (state.config.voiceURI) {
          const voices = synth.getVoices ? synth.getVoices() : [];
          const v = voices.find((vv) => vv && vv.voiceURI === state.config.voiceURI);
          if (v) u.voice = v;
        }
        synth.speak(u);
      } catch (e) {
        return;
      }
    }

    function initVoiceOptions() {
      if (!els.voiceSelect) return;
      const synth = window.speechSynthesis;
      if (!synth || !synth.getVoices) return;

      const voices = synth.getVoices();
      const previous = els.voiceSelect.value;
      const desired = state.config.voiceURI ? String(state.config.voiceURI) : '';

      els.voiceSelect.innerHTML = '<option value="">系统默认</option>';

      for (const v of voices) {
        if (!v || !v.voiceURI) continue;
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.textContent = v.lang ? `${v.name} (${v.lang})` : v.name;
        els.voiceSelect.appendChild(opt);
      }

      const trySet = (val) => {
        if (!val) return false;
        const exists = Array.from(els.voiceSelect.options).some((o) => o.value === val);
        if (!exists) return false;
        els.voiceSelect.value = val;
        return true;
      };

      const pickDefaultVoiceURI = () => {
        const googleCN = voices.find((v) => v && v.lang === 'zh-CN' && v.name === 'Google 普通话（中国大陆）');
        if (googleCN && googleCN.voiceURI) return googleCN.voiceURI;

        const anyZhCN = voices.find((v) => v && v.lang === 'zh-CN');
        if (anyZhCN && anyZhCN.voiceURI) return anyZhCN.voiceURI;

        return '';
      };

      const defaultVoiceURI = pickDefaultVoiceURI();

      if (trySet(desired)) {
        return;
      }
      if (trySet(previous)) {
        return;
      }
      if (!desired && defaultVoiceURI && trySet(defaultVoiceURI)) {
        state.config.voiceURI = defaultVoiceURI;
        saveState();
        return;
      }

      els.voiceSelect.value = '';
    }

    if (window.speechSynthesis && typeof window.speechSynthesis.addEventListener === 'function') {
      window.speechSynthesis.addEventListener('voiceschanged', () => {
        initVoiceOptions();
        state.config.voiceURI = els.voiceSelect && els.voiceSelect.value ? String(els.voiceSelect.value) : '';
        saveState();
      });
    }

    if (els.voiceSelect) {
      els.voiceSelect.addEventListener('change', () => {
        state.config.voiceURI = els.voiceSelect.value ? String(els.voiceSelect.value) : '';
        saveState();
        speak('语音音色已切换');
      });
    }

    let wakeLockSentinel = null;

    function isWakeLockSupported() {
      return !!(navigator && navigator.wakeLock && typeof navigator.wakeLock.request === 'function');
    }

    function updateWakeLockUI() {
      if (!els.wakeLockState) return;
      if (!state.config.wakeLock) {
        els.wakeLockState.textContent = '已关闭';
        return;
      }
      if (!isWakeLockSupported()) {
        els.wakeLockState.textContent = '不支持（请在系统设置里延长自动锁定）';
        return;
      }
      if (wakeLockSentinel) {
        els.wakeLockState.textContent = '已开启';
        return;
      }
      if (state.running && !state.paused && state.phase !== 'done') {
        els.wakeLockState.textContent = '申请中…';
        return;
      }
      els.wakeLockState.textContent = '待开启';
    }

    async function requestWakeLock() {
      if (!state.config.wakeLock) return;
      if (!isWakeLockSupported()) {
        updateWakeLockUI();
        return;
      }
      if (document.visibilityState !== 'visible') {
        updateWakeLockUI();
        return;
      }
      try {
        wakeLockSentinel = await navigator.wakeLock.request('screen');
        wakeLockSentinel.addEventListener('release', () => {
          wakeLockSentinel = null;
          updateWakeLockUI();
        });
      } catch (e) {
        wakeLockSentinel = null;
      } finally {
        updateWakeLockUI();
      }
    }

    async function releaseWakeLock() {
      if (!wakeLockSentinel) {
        updateWakeLockUI();
        return;
      }
      try {
        await wakeLockSentinel.release();
      } catch (e) {
      } finally {
        wakeLockSentinel = null;
        updateWakeLockUI();
      }
    }

    function syncWakeLockWithState() {
      if (state.running && !state.paused && state.phase !== 'done') {
        requestWakeLock();
      } else {
        releaseWakeLock();
      }
      updateWakeLockUI();
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        syncWakeLockWithState();
      }
    });

    if (els.wakeLockToggle) {
      els.wakeLockToggle.addEventListener('change', () => {
        state.config.wakeLock = !!els.wakeLockToggle.checked;
        saveState();
        syncWakeLockWithState();
      });
    }

    function beep(freq, durationMs, gainValue) {
      if (!state.config.sound) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;

      const ctx = new AC();
      const o = ctx.createOscillator();
      const g = ctx.createGain();

      o.type = 'sine';
      o.frequency.value = freq;
      g.gain.value = gainValue;

      o.connect(g);
      g.connect(ctx.destination);
      o.start();
      o.stop(ctx.currentTime + durationMs / 1000);

      setTimeout(() => {
        try { ctx.close(); } catch (e) {}
      }, durationMs + 60);
    }

    function updateUI() {
      els.stageText.textContent = stageLabel(state.phase);
      setDot(state.phase);

      els.timerText.textContent = formatMs(state.phaseRemainingMs);
      els.currentSet.textContent = String(state.currentSet);
      els.completedSets.textContent = String(state.completedSets);

      els.totalSets.textContent = String(state.config.totalSets);
      els.targetSets.textContent = String(state.config.totalSets);

      const pct = state.phaseDurationMs > 0 ? (1 - state.phaseRemainingMs / state.phaseDurationMs) : 0;
      const pctClamped = clamp(pct, 0, 1);
      els.phaseBar.style.width = `${(pctClamped * 100).toFixed(1)}%`;
      els.phaseProgressText.textContent = `${Math.round(pctClamped * 100)}%`;

      const canStart = state.phase === 'idle' || state.phase === 'done';
      els.btnStart.disabled = !canStart;

      els.btnPause.disabled = !(state.running && !state.paused && state.phase !== 'done');
      els.btnResume.disabled = !(state.running && state.paused && state.phase !== 'done');

      if (state.phase === 'done') {
        els.runState.textContent = '已完成';
      } else if (!state.running) {
        els.runState.textContent = '未开始';
      } else if (state.paused) {
        els.runState.textContent = '暂停中';
      } else {
        els.runState.textContent = '进行中';
      }

      const today = new Date();
      const day = `${today.getFullYear()}-${pad2(today.getMonth() + 1)}-${pad2(today.getDate())}`;
      const started = state.startedAtLocalISO ? new Date(state.startedAtLocalISO) : null;
      if (started) {
        const sday = `${started.getFullYear()}-${pad2(started.getMonth() + 1)}-${pad2(started.getDate())}`;
        els.todaySummary.textContent = sday === day ? `${state.completedSets}/${state.config.totalSets} 组` : `${state.completedSets}/${state.config.totalSets} 组（非今日开始）`;
      } else {
        els.todaySummary.textContent = `${state.completedSets}/${state.config.totalSets} 组`;
      }
    }

    function setPhase(phase, durationMs) {
      state.phase = phase;
      state.phaseDurationMs = Math.max(0, durationMs);
      state.phaseRemainingMs = Math.max(0, durationMs);
      state.lastTs = null;
      updateUI();
      saveState();
    }

    function startRoutine() {
      state.config = readConfigFromInputs();
      applyConfigToInputs(state.config);

      state.running = true;
      state.paused = false;
      state.completedSets = 0;
      state.currentSet = 1;
      state.startedAtLocalISO = new Date().toISOString();

      setPhase('work', state.config.workSeconds * 1000);
      toast(`开始第 ${state.currentSet} 组燕子飞。`);
      speak(`开始第${state.currentSet}组燕子飞`);
      beep(660, 160, 0.06);

      runTicker();
      syncWakeLockWithState();
    }

    function pauseRoutine() {
      if (!state.running || state.paused || state.phase === 'done') return;
      state.paused = true;
      state.lastTs = null;
      toast('已暂停。');
      syncWakeLockWithState();
      updateUI();
      saveState();
    }

    function resumeRoutine() {
      if (!state.running || !state.paused || state.phase === 'done') return;
      state.paused = false;
      state.lastTs = null;
      toast('继续。');
      syncWakeLockWithState();
      updateUI();
      saveState();
    }

    function resetRoutine() {
      const ok = confirm('确定要重置吗？这会清空当前进度。');
      if (!ok) return;

      state.config = readConfigFromInputs();
      applyConfigToInputs(state.config);

      state.phase = 'idle';
      state.running = false;
      state.paused = false;
      state.currentSet = 1;
      state.completedSets = 0;
      state.phaseDurationMs = state.config.workSeconds * 1000;
      state.phaseRemainingMs = state.phaseDurationMs;
      state.lastTs = null;
      state.startedAtLocalISO = null;

      clearSavedState();
      toast('已重置。');
      syncWakeLockWithState();
      updateUI();
      saveState();
    }

    function finishRoutine() {
      state.phase = 'done';
      state.running = false;
      state.paused = false;
      state.phaseDurationMs = 0;
      state.phaseRemainingMs = 0;
      state.lastTs = null;
      toast('全部完成！');
      syncWakeLockWithState();
      updateUI();
      saveState();
      beep(880, 120, 0.06);
      setTimeout(() => beep(660, 140, 0.06), 160);
      setTimeout(() => beep(990, 160, 0.06), 340);
    }

    function stepTransition() {
      if (state.phase === 'work') {
        state.completedSets = state.currentSet;
        if (state.currentSet >= state.config.totalSets) {
          finishRoutine();
          return;
        }

        if (state.config.restSeconds > 0) {
          toast(`休息 ${state.config.restSeconds} 秒。`);
          speak(`休息${state.config.restSeconds}秒`);
          beep(440, 140, 0.05);
          setPhase('rest', state.config.restSeconds * 1000);
        } else {
          state.currentSet += 1;
          toast(`开始第 ${state.currentSet} 组燕子飞。`);
          speak(`开始第${state.currentSet}组燕子飞`);
          beep(660, 160, 0.06);
          setPhase('work', state.config.workSeconds * 1000);
        }
        return;
      }

      if (state.phase === 'rest') {
        state.currentSet += 1;
        toast(`开始第 ${state.currentSet} 组燕子飞。`);
        speak(`开始第${state.currentSet}组燕子飞`);
        beep(660, 160, 0.06);
        setPhase('work', state.config.workSeconds * 1000);
        return;
      }
    }

    function tick(ts) {
      if (!state.running || state.paused || state.phase === 'done') return;

      if (state.lastTs == null) {
        state.lastTs = ts;
        return;
      }

      const delta = Math.max(0, ts - state.lastTs);
      state.lastTs = ts;

      state.phaseRemainingMs = Math.max(0, state.phaseRemainingMs - delta);
      updateUI();

      if (state.phaseRemainingMs <= 0) {
        stepTransition();
      }

      saveState();
    }

    function runTicker() {
      if (tickTimer) return;
      tickTimer = setInterval(() => {
        tick(nowMs());
      }, 120);
    }

    function stopTickerIfIdle() {
      if (state.running) return;
      if (!tickTimer) return;
      clearInterval(tickTimer);
      tickTimer = null;
    }

    function toggleStartPauseBySpace() {
      if (state.phase === 'idle' || state.phase === 'done') {
        startRoutine();
        return;
      }

      if (!state.running) {
        state.running = true;
        state.paused = false;
        runTicker();
        updateUI();
        saveState();
        return;
      }

      if (state.paused) resumeRoutine();
      else pauseRoutine();
    }

    els.btnStart.addEventListener('click', startRoutine);
    els.btnPause.addEventListener('click', pauseRoutine);
    els.btnResume.addEventListener('click', resumeRoutine);
    els.btnReset.addEventListener('click', resetRoutine);

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        toggleStartPauseBySpace();
      }
    });

    function boot() {
      const loaded = loadState();

      if (loaded) {
        applyConfigToInputs(state.config);
        if (state.phase === 'idle' || state.phase === 'done') {
          toast('已恢复上次配置。点击“开始”继续。');
        } else {
          toast('已恢复上次进度（默认处于暂停态）。点击“继续”。');
          state.running = true;
          state.paused = true;
          runTicker();
        }
      } else {
        state.config = readConfigFromInputs();
        applyConfigToInputs(state.config);
        state.phaseDurationMs = state.config.workSeconds * 1000;
        state.phaseRemainingMs = state.phaseDurationMs;
        saveState();
      }

      initVoiceOptions();
      syncWakeLockWithState();

      updateUI();
      stopTickerIfIdle();
    }

    boot();
  </script>
</body>
</html>
